import{C as F,L as C,S as K,O as Z,H as U,F as H,M as W,P as $,W as V,R as D,U as B,a as ee,D as te,b as P,c as z,T as O,d as ae,I as re,e as ie,B as ne,f as se,g as E,h as L,i as oe,j as de,k as N,l as le,N as he,V as R}from"./three-Dlbs-qyx.js";const X=(c,e,t)=>{let r;switch(c){case E:r=new Uint8ClampedArray(e*t*4);break;case U:r=new Uint16Array(e*t*4);break;case se:r=new Uint32Array(e*t*4);break;case ne:r=new Int8Array(e*t*4);break;case ie:r=new Int16Array(e*t*4);break;case re:r=new Int32Array(e*t*4);break;case H:r=new Float32Array(e*t*4);break;default:throw new Error("Unsupported data type")}return r};let S;const fe=(c,e,t,r)=>{if(S!==void 0)return S;const i=new V(1,1,r);e.setRenderTarget(i);const a=new W(new $,new ae({color:16777215}));e.render(a,t),e.setRenderTarget(null);const s=X(c,i.width,i.height);return e.readRenderTargetPixels(i,0,0,i.width,i.height,s),i.dispose(),a.geometry.dispose(),a.material.dispose(),S=s[0]!==0,S};class G{constructor(e){var t,r,i,a,s,n,h,l,g,f,o,y,p,w,v,x;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(M){throw this._renderer.setRenderTarget(null),M}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const T={format:D,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((t=e.renderTargetOptions)===null||t===void 0?void 0:t.anisotropy)!==void 0?(r=e.renderTargetOptions)===null||r===void 0?void 0:r.anisotropy:1,generateMipmaps:((i=e.renderTargetOptions)===null||i===void 0?void 0:i.generateMipmaps)!==void 0?(a=e.renderTargetOptions)===null||a===void 0?void 0:a.generateMipmaps:!1,magFilter:((s=e.renderTargetOptions)===null||s===void 0?void 0:s.magFilter)!==void 0?(n=e.renderTargetOptions)===null||n===void 0?void 0:n.magFilter:C,minFilter:((h=e.renderTargetOptions)===null||h===void 0?void 0:h.minFilter)!==void 0?(l=e.renderTargetOptions)===null||l===void 0?void 0:l.minFilter:C,samples:((g=e.renderTargetOptions)===null||g===void 0?void 0:g.samples)!==void 0?(f=e.renderTargetOptions)===null||f===void 0?void 0:f.samples:void 0,wrapS:((o=e.renderTargetOptions)===null||o===void 0?void 0:o.wrapS)!==void 0?(y=e.renderTargetOptions)===null||y===void 0?void 0:y.wrapS:F,wrapT:((p=e.renderTargetOptions)===null||p===void 0?void 0:p.wrapT)!==void 0?(w=e.renderTargetOptions)===null||w===void 0?void 0:w.wrapT:F};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=G.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new K,this._camera=new Z,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!fe(this._type,this._renderer,this._camera,T)){let M;switch(this._type){case U:M=this._renderer.extensions.has("EXT_color_buffer_float")?H:void 0;break}M!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${H}`),this._type=M):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new W(new $,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new V(this.width,this.height,T),this._renderTarget.texture.mapping=((v=e.renderTargetOptions)===null||v===void 0?void 0:v.mapping)!==void 0?(x=e.renderTargetOptions)===null||x===void 0?void 0:x.mapping:B}static instantiateRenderer(){const e=new ee;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=X(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const t=new te(this.toArray(),this.width,this.height,D,this._type,e?.mapping||B,e?.wrapS||F,e?.wrapT||F,e?.magFilter||C,e?.minFilter||C,e?.anisotropy||1,P);return t.generateMipmaps=e?.generateMipmaps!==void 0?e?.generateMipmaps:!1,t}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof z&&Object.values(this.material.uniforms).forEach(t=>{t.value instanceof O&&t.value.dispose()}),Object.values(this.material).forEach(t=>{t instanceof O&&t.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const ge=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,ce=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class pe extends z{constructor({gamma:e,offsetHdr:t,offsetSdr:r,gainMapMin:i,gainMapMax:a,maxDisplayBoost:s,hdrCapacityMin:n,hdrCapacityMax:h,sdr:l,gainMap:g}){super({name:"GainMapDecoderMaterial",vertexShader:ge,fragmentShader:ce,uniforms:{sdr:{value:l},gainMap:{value:g},gamma:{value:new R(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new R().fromArray(t)},offsetSdr:{value:new R().fromArray(r)},gainMapMin:{value:new R().fromArray(i)},gainMapMax:{value:new R().fromArray(a)},weightFactor:{value:(Math.log2(s)-n)/(h-n)}},blending:he,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=s,this._hdrCapacityMin=n,this._hdrCapacityMax=h,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const t=this.uniforms.gamma.value;t.x=1/e[0],t.y=1/e[1],t.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class J extends Error{}class j extends Error{}const A=(c,e,t)=>{const r=new RegExp(`${e}="([^"]*)"`,"i").exec(c);if(r)return r[1];const i=new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`,"i").exec(c);if(i){const a=i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return a&&a.length===3?a.map(s=>s.replace(/<\/?rdf:li>/g,"")):i[1].trim()}if(t!==void 0)return t;throw new Error(`Can't find ${e} in gainmap metadata`)},me=c=>{let e;typeof TextDecoder<"u"?e=new TextDecoder().decode(c):e=c.toString();let t=e.indexOf("<x:xmpmeta");for(;t!==-1;){const r=e.indexOf("x:xmpmeta>",t),i=e.slice(t,r+10);try{const a=A(i,"hdrgm:GainMapMin","0"),s=A(i,"hdrgm:GainMapMax"),n=A(i,"hdrgm:Gamma","1"),h=A(i,"hdrgm:OffsetSDR","0.015625"),l=A(i,"hdrgm:OffsetHDR","0.015625"),g=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),f=g?g[1]:"0",o=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);if(!o)throw new Error("Incomplete gainmap metadata");const y=o[1];return{gainMapMin:Array.isArray(a)?a.map(p=>parseFloat(p)):[parseFloat(a),parseFloat(a),parseFloat(a)],gainMapMax:Array.isArray(s)?s.map(p=>parseFloat(p)):[parseFloat(s),parseFloat(s),parseFloat(s)],gamma:Array.isArray(n)?n.map(p=>parseFloat(p)):[parseFloat(n),parseFloat(n),parseFloat(n)],offsetSdr:Array.isArray(h)?h.map(p=>parseFloat(p)):[parseFloat(h),parseFloat(h),parseFloat(h)],offsetHdr:Array.isArray(l)?l.map(p=>parseFloat(p)):[parseFloat(l),parseFloat(l),parseFloat(l)],hdrCapacityMin:parseFloat(f),hdrCapacityMax:parseFloat(y)}}catch{}t=e.indexOf("<x:xmpmeta",r)}};class ue{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((t,r)=>{const i=this.options.debug,a=new DataView(e.buffer);if(a.getUint16(0)!==65496){r(new Error("Not a valid jpeg"));return}const s=a.byteLength;let n=2,h=0,l;for(;n<s;){if(++h>250){r(new Error(`Found no marker after ${h} loops 😵`));return}if(a.getUint8(n)!==255){r(new Error(`Not a valid marker at offset 0x${n.toString(16)}, found: 0x${a.getUint8(n).toString(16)}`));return}if(l=a.getUint8(n+1),i&&console.log(`Marker: ${l.toString(16)}`),l===226){i&&console.log("Found APP2 marker (0xffe2)");const g=n+4;if(a.getUint32(g)===1297106432){const f=g+4;let o;if(a.getUint16(f)===18761)o=!1;else if(a.getUint16(f)===19789)o=!0;else{r(new Error("No valid endianness marker found in TIFF header"));return}if(a.getUint16(f+2,!o)!==42){r(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const y=a.getUint32(f+4,!o);if(y<8){r(new Error("Not valid TIFF data! (First offset less than 8)"));return}const p=f+y,w=a.getUint16(p,!o),v=p+2;let x=0;for(let u=v;u<v+12*w;u+=12)a.getUint16(u,!o)===45057&&(x=a.getUint32(u+8,!o));const M=p+2+w*12+4,b=[];for(let u=M;u<M+x*16;u+=16){const m={MPType:a.getUint32(u,!o),size:a.getUint32(u+4,!o),dataOffset:a.getUint32(u+8,!o),dependantImages:a.getUint32(u+12,!o),start:-1,end:-1,isFII:!1};m.dataOffset?(m.start=f+m.dataOffset,m.isFII=!1):(m.start=0,m.isFII=!0),m.end=m.start+m.size,b.push(m)}if(this.options.extractNonFII&&b.length){const u=new Blob([a]),m=[];for(const _ of b){if(_.isFII&&!this.options.extractFII)continue;const I=u.slice(_.start,_.end+1,"image/jpeg");m.push(I)}t(m)}}}n+=2+a.getUint16(n+2)}})}}const ye=async c=>{const e=me(c);if(!e)throw new j("Gain map XMP metadata not found");const r=await new ue({extractFII:!0,extractNonFII:!0}).extract(c);if(r.length!==2)throw new J("Gain map recovery image not found");return{sdr:new Uint8Array(await r[0].arrayBuffer()),gainMap:new Uint8Array(await r[1].arrayBuffer()),metadata:e}},k=c=>new Promise((e,t)=>{const r=document.createElement("img");r.onload=()=>{e(r)},r.onerror=i=>{t(i)},r.src=URL.createObjectURL(c)});class Y extends oe{constructor(e,t){super(t),e&&(this._renderer=e),this._internalLoadingManager=new de}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new pe({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new O,sdr:new O});return new G({width:16,height:16,type:U,colorSpace:P,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,t,r,i){const a=i?new Blob([i],{type:"image/jpeg"}):void 0,s=new Blob([r],{type:"image/jpeg"});let n,h,l=!1;if(typeof createImageBitmap>"u"){const o=await Promise.all([a?k(a):Promise.resolve(void 0),k(s)]);h=o[0],n=o[1],l=!0}else{const o=await Promise.all([a?createImageBitmap(a,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(s,{imageOrientation:"flipY"})]);h=o[0],n=o[1]}const g=new O(h||new ImageData(2,2),B,F,F,C,N,D,E,1,P);g.flipY=l,g.needsUpdate=!0;const f=new O(n,B,F,F,C,N,D,E,1,le);f.flipY=l,f.needsUpdate=!0,e.width=n.width,e.height=n.height,e.material.gainMap=g,e.material.sdr=f,e.material.gainMapMin=t.gainMapMin,e.material.gainMapMax=t.gainMapMax,e.material.offsetHdr=t.offsetHdr,e.material.offsetSdr=t.offsetSdr,e.material.gamma=t.gamma,e.material.hdrCapacityMin=t.hdrCapacityMin,e.material.hdrCapacityMax=t.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,t.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class we extends Y{load([e,t,r],i,a,s){const n=this.prepareQuadRenderer();let h,l,g;const f=async()=>{if(h&&l&&g){try{await this.render(n,g,h,l)}catch(d){this.manager.itemError(e),this.manager.itemError(t),this.manager.itemError(r),typeof s=="function"&&s(d),n.disposeOnDemandRenderer();return}typeof i=="function"&&i(n),this.manager.itemEnd(e),this.manager.itemEnd(t),this.manager.itemEnd(r),n.disposeOnDemandRenderer()}};let o=!0,y=0,p=0,w=!0,v=0,x=0,T=!0,M=0,b=0;const u=()=>{if(typeof a=="function"){const d=y+v+M,Q=p+x+b,q=o&&w&&T;a(new ProgressEvent("progress",{lengthComputable:q,loaded:Q,total:d}))}};this.manager.itemStart(e),this.manager.itemStart(t),this.manager.itemStart(r);const m=new L(this._internalLoadingManager);m.setResponseType("arraybuffer"),m.setRequestHeader(this.requestHeader),m.setPath(this.path),m.setWithCredentials(this.withCredentials),m.load(e,async d=>{if(typeof d=="string")throw new Error("Invalid sdr buffer");h=d,await f()},d=>{o=d.lengthComputable,p=d.loaded,y=d.total,u()},d=>{this.manager.itemError(e),typeof s=="function"&&s(d)});const _=new L(this._internalLoadingManager);_.setResponseType("arraybuffer"),_.setRequestHeader(this.requestHeader),_.setPath(this.path),_.setWithCredentials(this.withCredentials),_.load(t,async d=>{if(typeof d=="string")throw new Error("Invalid gainmap buffer");l=d,await f()},d=>{w=d.lengthComputable,x=d.loaded,v=d.total,u()},d=>{this.manager.itemError(t),typeof s=="function"&&s(d)});const I=new L(this._internalLoadingManager);return I.setRequestHeader(this.requestHeader),I.setPath(this.path),I.setWithCredentials(this.withCredentials),I.load(r,async d=>{if(typeof d!="string")throw new Error("Invalid metadata string");g=JSON.parse(d),await f()},d=>{T=d.lengthComputable,b=d.loaded,M=d.total,u()},d=>{this.manager.itemError(r),typeof s=="function"&&s(d)}),n}}class ve extends Y{load(e,t,r,i){const a=this.prepareQuadRenderer(),s=new L(this._internalLoadingManager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(this.withCredentials),this.manager.itemStart(e),s.load(e,async n=>{if(typeof n=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const h=new Uint8Array(n);let l,g,f;try{const o=await ye(h);l=o.sdr,g=o.gainMap,f=o.metadata}catch(o){if(o instanceof j||o instanceof J)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),f={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},l=h;else throw o}try{await this.render(a,f,l,g)}catch(o){this.manager.itemError(e),typeof i=="function"&&i(o),a.disposeOnDemandRenderer();return}typeof t=="function"&&t(a),this.manager.itemEnd(e),a.disposeOnDemandRenderer()},r,n=>{this.manager.itemError(e),typeof i=="function"&&i(n)}),a}}export{we as G,ve as H};
